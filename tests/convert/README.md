# Example of Conversion

## Files
    - [`lib.h`](lib.h) from the library to bind
    - [`generator/generator.ml`](generator/generator.ml) written by the user, describe the stub function and type to generate
    - [`mylib_stub.h`](mylib_stub.h) generated by camlid from `generator/generator.ml`, contains the definition of the generated type. Includes `lib.h`.
    - [`mylib_stub.c`](mylib_stub.c) generated by camlid from `generator/generator.ml`, contains the definition of the generated function stub. Includes `mylib_stub.h` and `defs.h`.
    - [`defs.h`](defs.h) written by the user. Includes `mylib_stub.h`.

## Explanation
    In this example a C function return some data in an argument if its return
status is true. So the result of the corresponding function is an algebraic type:

```
type result = | Data of int | Error of int
```

This type is generated by camlid with the following corresponding C type and a translation function:

```
typedef struct {
  enum { camlid_result_Data, camlid_result_Error} tag;
  union {
    struct { intptr_t data; } Data;
    struct { intptr_t error; } Error;} u; } camlid_result;
```

Additionally, two C smart-constructors are defined:

```
// @brief Fill [dst] with the constructor Data of result
// @param dst structure to fill
// @param data reference is assigned to the constructor field
static inline void camlid_mk_result_Data(camlid_result* dst, intptr_t* data)

// @brief Fill [dst] with the constructor Error of result
// @param dst structure to fill
// @param error reference is assigned to the constructor field
static inline void camlid_mk_result_Error(camlid_result* dst,
intptr_t* error)
```

So the user only need to define a function that takes the error and the data and fill a `camlid_result`:

```
static void combine_data_or_status(camlid_result *dst, intptr_t *status, intptr_t *data)
{
    if (*status)
    {
        camlid_mk_result_Error(dst, status);
    }
    else {
        camlid_mk_result_Data(dst, data);
    };
}
```
